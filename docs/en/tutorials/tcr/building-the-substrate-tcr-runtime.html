<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Building the Substrate TCR runtime · Substrate Developer Hub</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;This is Part 1 of the guide [Building a Token Curated Registry DAppChain on Substrate](TODO: INSERT LINK TO GUIDE). This part covers the implementation of the Substrate runtime modules needed for the Token Curated Registry runtime.&lt;/p&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Building the Substrate TCR runtime · Substrate Developer Hub"/><meta property="og:type" content="website"/><meta property="og:url" content="https://substrate-developer-hub.github.io//"/><meta property="og:description" content="&lt;p&gt;This is Part 1 of the guide [Building a Token Curated Registry DAppChain on Substrate](TODO: INSERT LINK TO GUIDE). This part covers the implementation of the Substrate runtime modules needed for the Token Curated Registry runtime.&lt;/p&gt;
"/><meta property="og:image" content="https://substrate-developer-hub.github.io/img/Substrate-logo.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://substrate-developer-hub.github.io/img/Substrate-logo.svg"/><link rel="shortcut icon" href="/img/Substrate-logo.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/en"><img class="logo" src="/img/Substrate-logo.svg" alt="Substrate Developer Hub"/><h2 class="headerTitleWithLogo">Substrate Developer Hub</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/en/quickstart/getting-started" target="_self">Docs</a></li><li class=""><a href="/en/tutorials" target="_self">Tutorials</a></li><li class=""><a href="https://www.parity.io/blog/" target="_self">Blog</a></li><li class=""><a href="/en/community/support" target="_self">Community</a></li><li class=""><a href="https://github.com/substrate-developer-hub/" target="_self">GitHub</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/zh-CN/tutorials/tcr/building-the-substrate-tcr-runtime">中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Building the Substrate TCR runtime</h1></header><article><div><span><p>This is Part 1 of the guide [Building a Token Curated Registry DAppChain on Substrate](TODO: INSERT LINK TO GUIDE). This part covers the implementation of the Substrate runtime modules needed for the Token Curated Registry runtime.</p>
<p>The code for the sample TCR runtime covered in this guide is available in <a href="https://github.com/parity-samples/substrate-tcr/">this GitHub repository</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="step-1-setup-and-prerequisites"></a><a href="#step-1-setup-and-prerequisites" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 1: Setup and prerequisites</h2>
<p>In this guide, we will directly jump into the TCR runtime development using Substrate node bootstrapped using the <code>substrate-node-new</code> script. This guide is intended to walk you through the overall process of creating a DAppChain using Substrate. It does not cover the &quot;getting started&quot; and other basic concepts about Substrate. To get an overview of these concepts, it is highly recommended that you go through the <a href="https://shawntabrizi.github.io/substrate-collectables-workshop/">Substrate Collectibles tutorial</a> before proceeding further.</p>
<p>Let's start with a new Substrate runtime node. We recommend going through the <a href="https://substrate.readme.io/docs/substrate-up-scripts">Substrate setup scripts tutorial</a> to spin up a hack-ready node runtime using the <code>substrate-node-new</code> script.</p>
<h2><a class="anchor" aria-hidden="true" id="step-2-module-trait-and-types"></a><a href="#step-2-module-trait-and-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 2: Module trait and types</h2>
<p>The first step towards building a Substrate runtime module is to define what other SRML modules we could use in our module. There are plenty of SRML modules that ship with the Substrate codebase and we recommend using them, when needed. To use any of the existing modules, we need to import and specify them in the module trait of our custom module.</p>
<p>For example, in this runtime we need the capability to calculate and compare timestamps for the TCR parameters - apply stage length and commit stage length. We will use the <a href="https://github.com/paritytech/substrate/tree/master/srml/timestamp"><code>timestamp</code> SRML module</a> to achieve this functionality.</p>
<p>Here's how the module configuration trait declaration for the TCR module looks like.</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span>: timestamp::Trait + token::Trait {
  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Event</span></span>: <span class="hljs-built_in">From</span>&lt;Event&lt;<span class="hljs-keyword">Self</span>&gt;&gt; + <span class="hljs-built_in">Into</span>&lt;&lt;<span class="hljs-keyword">Self</span> <span class="hljs-keyword">as</span> system::Trait&gt;::Event&gt;;
}
</code></pre>
<p>In the above snippet, we have the TCR module configuration trait inheriting from the <code>timestamp</code> module trait. In addition, it also inherits from the <code>token</code> module trait. It is important to import these modules in your module before you use them in the module trait. In the following snippet we are importing the <code>timestamp</code> module from the SRML and the <code>token</code> module from the local crate.</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">use</span> {system::ensure_signed, timestamp};
<span class="hljs-keyword">use</span> crate::token;
</code></pre>
<p>The token module is another custom module that we need in order to support the token functionality for TCR curation functions. We would not be going into the implementation details of the <code>token</code> module in this guide as its code is pretty much self explanatory. Basically, the <code>token</code> module implements the ERC20 interface with some additional functions (lock and unlock). It is available as part of the TCR sample code base <a href="https://github.com/parity-samples/substrate-tcr/blob/master/runtime/src/token.rs">here</a>.</p>
<p>Remember to add references of your <code>token.rs</code> and <code>tcr.rs</code> modules to the <code>lib.rs</code>, and add them to the <code>construct_runtime!</code> macro.</p>
<h2><a class="anchor" aria-hidden="true" id="step-3-declaring-the-runtime-storage"></a><a href="#step-3-declaring-the-runtime-storage" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 3: Declaring the runtime storage</h2>
<p>The first thing we would want to do is define the storage for our TCR runtime.</p>
<p>When building a DApp or a DAppChain it is very important to decide what gets stored on-chain and what doesn't. It is recommended that you store on-chain only the data which is critical for conflict resolution; anything else can and should be stored off-chain. Properly defined storage is important for your chain's economic security in order to match resources paid by the user with resources provided by the network. If the storage items become large or unwieldy to deal with, then the transactions will become complex, risking an economic denial of service attack on your chain.</p>
<p>For the TCR runtime, let's see what could be the least amount of information stored on chain. To perform the basic curation operations for the TCR, we would store collections of listings (the registry), challenges, polls and votes. We would also need the TCR parameters to be stored as storage values.</p>
<h3><a class="anchor" aria-hidden="true" id="data-structures-for-on-chain-tcr-data"></a><a href="#data-structures-for-on-chain-tcr-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Data structures for on-chain TCR data</h3>
<p>First, to store the details for listings, challenges, polls and votes we would be defining the respective data structures using <code>Struct</code>.</p>
<pre><code class="hljs css language-rust"><span class="hljs-meta">#[derive(Encode, Decode, Default, Clone, PartialEq)]</span>
<span class="hljs-meta">#[cfg_attr(feature = <span class="hljs-meta-string">"std"</span>, derive(Debug))]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Listing</span></span>&lt;U, V, W&gt; {
  id: <span class="hljs-built_in">u32</span>,
  data: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;,
  deposit: U,
  owner: V,
  application_expiry: W,
  whitelisted: <span class="hljs-built_in">bool</span>,
  challenge_id: <span class="hljs-built_in">u32</span>,
}

<span class="hljs-meta">#[derive(Encode, Decode, Default, Clone, PartialEq)]</span>
<span class="hljs-meta">#[cfg_attr(feature = <span class="hljs-meta-string">"std"</span>, derive(Debug))]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Challenge</span></span>&lt;T, U, V, W&gt; {
  listing_hash: T,
  deposit: U,
  owner: V,
  voting_ends: W,
  resolved: <span class="hljs-built_in">bool</span>,
  reward_pool: U,
  total_tokens: U
}

<span class="hljs-meta">#[derive(Encode, Decode, Default, Clone, PartialEq)]</span>
<span class="hljs-meta">#[cfg_attr(feature = <span class="hljs-meta-string">"std"</span>, derive(Debug))]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vote</span></span>&lt;U&gt; {
  value: <span class="hljs-built_in">bool</span>,
  deposit: U,
  claimed: <span class="hljs-built_in">bool</span>,
}

<span class="hljs-meta">#[derive(Encode, Decode, Default, Clone, PartialEq)]</span>
<span class="hljs-meta">#[cfg_attr(feature = <span class="hljs-meta-string">"std"</span>, derive(Debug))]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Poll</span></span>&lt;T, U&gt; {
  listing_hash: T,
  votes_for: U,
  votes_against: U,
  passed: <span class="hljs-built_in">bool</span>,
}
</code></pre>
<p>These structs have generic type parameters so that we can use any implementation of the respective types. The following sub-section describes how we are instantiating collections of these structs where we define the exact type in place of generic parameters. The <code>Moment</code> type comes from the <code>timestamp</code> module and the <code>TokenBalance</code> type comes from the <code>token</code> module.</p>
<h3><a class="anchor" aria-hidden="true" id="storage-declaration-using-the-decl_storage-macro"></a><a href="#storage-declaration-using-the-decl_storage-macro" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Storage declaration using the <code>decl_storage</code> macro</h3>
<p>Here's how the <code>decl_storage</code> macro looks for the TCR runtime. The comments describe each of the storage items.</p>
<pre><code class="hljs css language-rust">decl_storage! {
 <span class="hljs-class"><span class="hljs-keyword">trait</span>   <span class="hljs-title">Store</span></span> <span class="hljs-keyword">for</span> Module&lt;T: Trait&gt; <span class="hljs-keyword">as</span> Tcr {

    <span class="hljs-comment">// stores the owner in the genesis config</span>
    Owner get(owner) config(): T::AccountId;

    <span class="hljs-comment">// TCR parameter - minimum deposit</span>
    MinDeposit get(min_deposit) config(): <span class="hljs-built_in">Option</span>&lt;T::TokenBalance&gt;;

    <span class="hljs-comment">// TCR parameter - apply stage length - deadline for challenging before a listing gets accepted</span>
    ApplyStageLen get(apply_stage_len) config(): <span class="hljs-built_in">Option</span>&lt;T::Moment&gt;;

    <span class="hljs-comment">// TCR parameter - commit stage length - deadline for voting before a challenge gets resolved</span>
    CommitStageLen get(commit_stage_len) config(): <span class="hljs-built_in">Option</span>&lt;T::Moment&gt;;

    <span class="hljs-comment">// the TCR - list of proposals</span>
    Listings get(listings): map T::Hash =&gt; Listing&lt;T::TokenBalance, T::AccountId, T::Moment&gt;;

    <span class="hljs-comment">// to make querying of listings easier, maintaining a list of indexes and corresponding listing hashes</span>
    ListingCount get(listing_count): <span class="hljs-built_in">u32</span>;
    ListingIndexHash get(index_hash): map <span class="hljs-built_in">u32</span> =&gt; T::Hash;

    <span class="hljs-comment">// global nonce for poll count</span>
    PollNonce get(poll_nonce) config(): <span class="hljs-built_in">u32</span>;

    <span class="hljs-comment">// challenges</span>
    Challenges get(challenges): map <span class="hljs-built_in">u32</span> =&gt; Challenge&lt;T::Hash, T::TokenBalance, T::AccountId, T::Moment&gt;;

    <span class="hljs-comment">// polls</span>
    Polls get(polls): map <span class="hljs-built_in">u32</span> =&gt; Poll&lt;T::Hash, T::TokenBalance&gt;;

    <span class="hljs-comment">// votes</span>
    <span class="hljs-comment">// mapping is between a tuple of (poll id, Account Id) and a vec of votes</span>
    <span class="hljs-comment">// poll and vote have a 1:n relationship</span>
    Votes get(votes): map (<span class="hljs-built_in">u32</span>, T::AccountId) =&gt; Vote&lt;T::TokenBalance&gt;;

    }
}
</code></pre>
<p>As you can see, in addition to the storage items mentioned before, we have a few more storage items (<code>ListingCount</code>, <code>ListingIndexHash</code>) to make the data querying easier. These are completely optional and are not required by the TCR runtime for its core functionality.</p>
<h3><a class="anchor" aria-hidden="true" id="using-the-genesis-config"></a><a href="#using-the-genesis-config" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using the genesis config</h3>
<p>The genesis config is the state of the chain before the first block. This is useful in scenarios when we want to use some parameters needed for subsequent transactions. For example, the TCR parameters are needed before any of the listings can be applied.</p>
<p>In Substrate, a storage value can be marked as part of the genesis config by adding the <code>config()</code> call to its declaration. In the TCR runtime, we have the following as part of the genesis config. Note that each of the declarations has <code>config()</code> in it.</p>
<pre><code class="hljs css language-rust"><span class="hljs-comment">// stores the owner in the genesis config</span>
Owner get(owner) config(): T::AccountId;

<span class="hljs-comment">// TCR parameter - minimum deposit</span>
MinDeposit get(min_deposit) config(): <span class="hljs-built_in">Option</span>&lt;T::TokenBalance&gt;;

<span class="hljs-comment">// TCR parameter - apply stage length - deadline for challenging before a listing gets accepted</span>
ApplyStageLen get(apply_stage_len) config(): <span class="hljs-built_in">Option</span>&lt;T::Moment&gt;;

<span class="hljs-comment">// TCR parameter - commit stage length - deadline for voting before a challenge gets resolved</span>
CommitStageLen get(commit_stage_len) config(): <span class="hljs-built_in">Option</span>&lt;T::Moment&gt;;
</code></pre>
<p>Marking a storage value as <code>config()</code> is just enabling it to be used as genesis config. To use it as the state before the first block, we also need to set a value for it.</p>
<p>To set the values for genesis config, we need to make some edits in the <code>chain_spec.rs</code> file.</p>
<p>First, we need to add a type name for the genesis config in the template runtime import. In the code snippet below, we have added <code>TcrConfig</code> in the runtime import for representing the genesis config of TCR runtime module</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">use</span> node_template_runtime::{
    AccountId, GenesisConfig, ConsensusConfig, TimestampConfig, BalancesConfig,
    SudoConfig, IndicesConfig, TcrConfig
};
</code></pre>
<p>Second, we need to add a section in the <code>testnet_genesis</code> function in the same <code>chain_spec.rs</code> file. For the TCR runtime and its genesis config parameters, here's how it looks.</p>
<pre><code class="hljs css language-rust">tcr: <span class="hljs-literal">Some</span>(TcrConfig {
    <span class="hljs-comment">// owner account id</span>
    owner: ed25519::Pair::from_seed(<span class="hljs-string">b"Alice "</span>).public().<span class="hljs-number">0</span>.into(),

    <span class="hljs-comment">// min deposit for proposals</span>
    min_deposit: <span class="hljs-number">100</span>,

    <span class="hljs-comment">// challenge time limit - for testing its set to 2 mins (120 sec)</span>
    apply_stage_len: <span class="hljs-number">120</span>,

    <span class="hljs-comment">// voting time limit - for testing its set to 4 mins (240 sec)</span>
    commit_stage_len: <span class="hljs-number">240</span>,

    <span class="hljs-comment">// initial poll/challenge set to 1</span>
    <span class="hljs-comment">// to avoid 0 values</span>
    poll_nonce: <span class="hljs-number">1</span>,
})
</code></pre>
<p>Here, we have assigned values to each of the storage items that were marked with <code>config()</code> in the runtime storage declaration inside the <code>decl_storage</code> macro. For example, the value for minimum deposit is 100 and this will be used right from the beginning of the chain so that the deposit on any new listing being applied can be validated against this value.</p>
<p>You can see the <code>chain_spec.rs</code> file with all the required edits <a href="https://github.com/parity-samples/substrate-tcr/blob/master/src/chain_spec.rs">here</a>.</p>
<p>This also concludes the work needed on the storage declaration and setup.</p>
<h2><a class="anchor" aria-hidden="true" id="step-4-declaring-events"></a><a href="#step-4-declaring-events" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 4: Declaring Events</h2>
<p>The next step for our runtime module development is declaring its events. In general, we need events so that the external world can listen to updates on the blockchain. If we do not have proper events in our runtime, the users would end up querying a lot of on-chain data.</p>
<p>Also, it is important to note that the runtime functions in Substrate do not return values on success. Their return value is either empty or an error message. Because of this, it becomes even more important to have events with the right parameters so that the state changes can be communicated to the clients and hence, users.</p>
<p>We can also use the events to build an off-chain cache of the on-chain data. This cache can then be used to query and analyze data in a more performant way. We will cover more on this in Part 3 of this guide.</p>
<p>For our TCR runtime module, we would have events to communicate updates on listings - proposal, challenge, vote, resolution, accepted/rejected and rewards claim. All these are logical steps in the life-cycle of a listing and corresponding challenges and should be communicated to the outside world.</p>
<p>In general, when developing a runtime module, you should ask yourself this question - &quot;What kind of updates will the client or the external user be interested in when using this runtime?&quot; Ideally, all these updates should be communicated as events.</p>
<p>For our TCR runtime, we have the following events declared using the <code>decl_event</code> macro.</p>
<pre><code class="hljs css language-rust">decl_event!(
    <span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Event</span></span>&lt;T&gt; <span class="hljs-keyword">where</span> 
        AccountId = &lt;T <span class="hljs-keyword">as</span> system::Trait&gt;::AccountId, 
        Balance = &lt;T <span class="hljs-keyword">as</span> token::Trait&gt;::TokenBalance, 
        Hash = &lt;T <span class="hljs-keyword">as</span> system::Trait&gt;::Hash,
    {
      <span class="hljs-comment">// when a listing is proposed</span>
      Proposed(AccountId, Hash, Balance),
      <span class="hljs-comment">// when a listing is challenged</span>
      Challenged(AccountId, Hash, <span class="hljs-built_in">u32</span>, Balance),
      <span class="hljs-comment">// when a challenge is voted on</span>
      Voted(AccountId, <span class="hljs-built_in">u32</span>, Balance),
      <span class="hljs-comment">// when a challenge is resolved</span>
      Resolved(Hash, <span class="hljs-built_in">u32</span>),
      <span class="hljs-comment">// when a listing is accepted in the registry</span>
      Accepted(Hash),
      <span class="hljs-comment">// when a listing is rejected from the registry</span>
      Rejected(Hash),
      <span class="hljs-comment">// when a vote reward is claimed for a challenge</span>
      Claimed(AccountId, <span class="hljs-built_in">u32</span>),
    }
);
</code></pre>
<p>At this point, we have our storage, genesis config, and events sorted. We are now good to proceed with the implementation of the runtime business logic.</p>
<h2><a class="anchor" aria-hidden="true" id="step-5-module-business-logic"></a><a href="#step-5-module-business-logic" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 5: Module business logic</h2>
<p>There is a reason why we are doing the business logic at the end. At this point, it becomes very clear what we intend to store and what we plan to communicate (events) in our module. This clarity can help a lot in optimizing the business logic. Let's begin.</p>
<h3><a class="anchor" aria-hidden="true" id="propose-a-listing"></a><a href="#propose-a-listing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Propose a listing</h3>
<p>The first function that our TCR runtime module needs to expose is to allow the proposal of a listing to the registry. In this function, we take as input the listing name and deposit. We then validate this input as per the TCR config parameters stored as genesis config. Then we deduct (lock) the deposit amount from the sender's balance using the <code>token</code> module. Finally, we store the listing as an instance of the <code>Listing</code> struct inside the <code>Listings</code> storage map.</p>
<p>Here's how the <code>Propose</code> function is implemented,</p>
<pre><code class="hljs css language-rust"><span class="hljs-comment">// propose a listing on the registry</span>
<span class="hljs-comment">// takes the listing name (data) as a byte vector</span>
<span class="hljs-comment">// takes deposit as stake backing the listing</span>
<span class="hljs-comment">// checks if the stake is less than minimum deposit needed</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">propose</span></span>(origin, data: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, <span class="hljs-meta">#[compact]</span> deposit: T::TokenBalance) -&gt; <span class="hljs-built_in">Result</span> {
  <span class="hljs-keyword">let</span> sender = ensure_signed(origin)?;

  <span class="hljs-comment">// to avoid byte arrays with unlimited length</span>
  ensure!(data.len() &lt;= <span class="hljs-number">256</span>, <span class="hljs-string">"listing data cannot be more than 256 bytes"</span>);

  <span class="hljs-keyword">let</span> min_deposit = Self::min_deposit().ok_or(<span class="hljs-string">"Min deposit not set"</span>)?;
  ensure!(deposit &gt;= min_deposit, <span class="hljs-string">"deposit should be more than min_deposit"</span>);

  <span class="hljs-comment">// set application expiry for the listing</span>
  <span class="hljs-comment">// using the `Timestamp` SRML module for getting the block timestamp</span>
  <span class="hljs-comment">// generating a future timestamp by adding the apply stage length</span>
  <span class="hljs-keyword">let</span> now = &lt;timestamp::Module&lt;T&gt;&gt;::get();
  <span class="hljs-keyword">let</span> apply_stage_len = Self::apply_stage_len().ok_or(<span class="hljs-string">"Apply stage length not set."</span>)?;
  <span class="hljs-keyword">let</span> app_exp = now.checked_add(&amp;apply_stage_len).ok_or(<span class="hljs-string">"Overflow when setting application expiry."</span>)?;

  <span class="hljs-keyword">let</span> hashed = &lt;T <span class="hljs-keyword">as</span> system::Trait&gt;::Hashing::hash(&amp;data);

  <span class="hljs-keyword">let</span> listing_id = Self::listing_count();

  <span class="hljs-comment">// create a new listing instance</span>
  <span class="hljs-keyword">let</span> listing = Listing {
    id: listing_id,
    data,
    deposit,
    owner: sender.clone(),
    whitelisted: <span class="hljs-literal">false</span>,
    challenge_id: <span class="hljs-number">0</span>,
    application_expiry: app_exp,
  };

  ensure!(!&lt;Listings&lt;T&gt;&gt;::exists(hashed), <span class="hljs-string">"Listing already exists"</span>);

  <span class="hljs-comment">// deduct the deposit for application</span>
  &lt;token::Module&lt;T&gt;&gt;::lock(sender.clone(), deposit, hashed.clone())?;

  &lt;ListingCount&lt;T&gt;&gt;::put(listing_id + <span class="hljs-number">1</span>);
  &lt;Listings&lt;T&gt;&gt;::insert(hashed, listing);
  &lt;ListingIndexHash&lt;T&gt;&gt;::insert(listing_id, hashed);

  <span class="hljs-comment">// let the world know</span>
  <span class="hljs-comment">// raise the event</span>
  Self::deposit_event(RawEvent::Proposed(sender, hashed.clone(), deposit));
  runtime_io::print(<span class="hljs-string">"Listing created!"</span>);

  <span class="hljs-literal">Ok</span>(())}
}
</code></pre>
<p>It is worth noting that we are doing all the checks and validations before touching the storage. This is <strong>very important</strong> as the state of the blockchain cannot be reversed if the logic fails or errors out. We need to be extremely careful before updating the storage. This is well described in the <a href="https://github.com/shawntabrizi/substrate-collectables-workshop/blob/master/2/tracking-all-kitties.md#verify-first-write-last">Substrate-Collectibles tutorial</a> also.</p>
<p>If you are using external modules in your module, make sure to check whether the functions from these external modules are doing any validations. If yes, make these function calls before updating any storage in your module. In this case, we are calling the <code>lock</code> function of the <code>token</code> module from the <code>propose</code> function of the <code>TCR</code> module. The <code>lock</code> function is verifying if the token balance of the proposer (origin) is more than the deposit. That's why we are calling it before inserting the listing. The <code>lock</code> function also updates storage (locking the user's funds), so it is important not to have any more operations that can fail after the user's funds are locked.</p>
<p>Finally, we raise the <code>Proposed</code> event to communicate to the external world that a new listing has been proposed in the registry.</p>
<h3><a class="anchor" aria-hidden="true" id="challenge-and-vote"></a><a href="#challenge-and-vote" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Challenge and Vote</h3>
<p>Similar to how we have implemented the <code>propose</code> function above, we implement the <code>challenge</code> and <code>vote</code> functions also. We follow the same pattern of doing all the checks and validations and then recording the updated state in the storage.</p>
<p>In the <strong>challenge</strong> function, we check if the listing exists and if it is still in the apply stage period. We also check if the deposit for challenge is at least equal to that of the listing. We then lock the deposit for challenge and store a new instance of the <code>Challenge</code> struct in the <code>Challenges</code> storage map. We also update the listing with the <code>challenge_id</code>. Finally we raise the <code>Challenged</code> event.</p>
<pre><code class="hljs css language-rust"><span class="hljs-comment">// challenge a listing</span>
<span class="hljs-comment">// for simplicity, only three checks are being done</span>
<span class="hljs-comment">//    a. if the listing exists</span>
<span class="hljs-comment">//    c. if the challenger is not the owner of the listing</span>
<span class="hljs-comment">//    b. if enough deposit is sent for challenge</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">challenge</span></span>(origin, listing_id: <span class="hljs-built_in">u32</span>, <span class="hljs-meta">#[compact]</span> deposit: T::TokenBalance) -&gt; <span class="hljs-built_in">Result</span> {
  <span class="hljs-keyword">let</span> sender = ensure_signed(origin)?;

  ensure!(&lt;ListingIndexHash&lt;T&gt;&gt;::exists(listing_id), <span class="hljs-string">"Listing not found."</span>);

  <span class="hljs-keyword">let</span> listing_hash = Self::index_hash(listing_id);
  <span class="hljs-keyword">let</span> listing = Self::listings(listing_hash);

  ensure!(listing.challenge_id == <span class="hljs-number">0</span>, <span class="hljs-string">"Listing is already challenged."</span>);
  ensure!(listing.owner != sender, <span class="hljs-string">"You cannot challenge your own listing."</span>);
  ensure!(deposit &gt;= listing.deposit, <span class="hljs-string">"Not enough deposit to challenge."</span>);

  <span class="hljs-comment">// get current time</span>
  <span class="hljs-keyword">let</span> now = &lt;timestamp::Module&lt;T&gt;&gt;::get();

  <span class="hljs-comment">// get commit stage length</span>
  <span class="hljs-keyword">let</span> commit_stage_len = Self::commit_stage_len().ok_or(<span class="hljs-string">"Commit stage length not set."</span>)?;
  <span class="hljs-keyword">let</span> voting_exp = now.checked_add(&amp;commit_stage_len).ok_or(<span class="hljs-string">"Overflow when setting voting expiry."</span>)?;

  <span class="hljs-comment">// check apply stage length not passed</span>
  <span class="hljs-comment">// ensure that now &lt;= listing.application_expiry</span>
  ensure!(listing.application_expiry &gt; now, <span class="hljs-string">"Apply stage length has passed."</span>);

  <span class="hljs-keyword">let</span> challenge = Challenge {
    listing_hash,
    deposit,
    owner: sender.clone(),
    voting_ends: voting_exp,
    resolved: <span class="hljs-literal">false</span>,
    reward_pool: &lt;T::TokenBalance <span class="hljs-keyword">as</span> As&lt;<span class="hljs-built_in">u64</span>&gt;&gt;::sa(<span class="hljs-number">0</span>),
    total_tokens: &lt;T::TokenBalance <span class="hljs-keyword">as</span> As&lt;<span class="hljs-built_in">u64</span>&gt;&gt;::sa(<span class="hljs-number">0</span>),
  };

  <span class="hljs-keyword">let</span> poll = Poll {
    listing_hash,
    votes_for: listing.deposit,
    votes_against: deposit,
    passed: <span class="hljs-literal">false</span>,
  };

  <span class="hljs-comment">// deduct the deposit for challenge</span>
  &lt;token::Module&lt;T&gt;&gt;::lock(sender.clone(), deposit, listing_hash)?;

  <span class="hljs-comment">// global poll nonce</span>
  <span class="hljs-comment">// helps keep the count of challenges and in mapping votes</span>
  <span class="hljs-keyword">let</span> poll_nonce = &lt;PollNonce&lt;T&gt;&gt;::get();
  <span class="hljs-comment">// add a new challenge and the corresponding poll in the respective collections</span>
  &lt;Challenges&lt;T&gt;&gt;::insert(poll_nonce, challenge);
  &lt;Polls&lt;T&gt;&gt;::insert(poll_nonce, poll);

  <span class="hljs-comment">// update listing with challenge id</span>
  &lt;Listings&lt;T&gt;&gt;::mutate(listing_hash, |listing| {
    listing.challenge_id = poll_nonce;
  });

  <span class="hljs-comment">// update the poll nonce</span>
  &lt;PollNonce&lt;T&gt;&gt;::put(poll_nonce + <span class="hljs-number">1</span>);

  <span class="hljs-comment">// raise the event</span>
  Self::deposit_event(RawEvent::Challenged(sender, listing_hash, poll_nonce, deposit));
  runtime_io::print(<span class="hljs-string">"Challenge created!"</span>);

  <span class="hljs-literal">Ok</span>(())
}
</code></pre>
<p>Similarly, in the <strong>vote</strong> function we check for existence of the listing and challenge. We also check if the commit stage period has passed or not. Based on the vote value (true or false) we add the vote deposit to either <code>votes_for</code> or <code>votes_against</code> fields in the corresponding poll instance. We then store a new instance of the <code>Vote</code> struct inside the <code>Votes</code> map and also raise the <code>Voted</code> event.</p>
<pre><code class="hljs css language-rust"><span class="hljs-comment">// registers a vote for a particular challenge</span>
<span class="hljs-comment">// checks if the listing is challenged and</span>
<span class="hljs-comment">// if the commit stage length has not passed</span>
<span class="hljs-comment">// to keep it simple, we just store the choice as a bool - true: aye; false: nay</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">vote</span></span>(origin, challenge_id: <span class="hljs-built_in">u32</span>, value: <span class="hljs-built_in">bool</span>, <span class="hljs-meta">#[compact]</span> deposit: T::TokenBalance) -&gt; <span class="hljs-built_in">Result</span> {
  <span class="hljs-keyword">let</span> sender = ensure_signed(origin)?;

  <span class="hljs-comment">// check if listing is challenged</span>
  ensure!(&lt;Challenges&lt;T&gt;&gt;::exists(challenge_id), <span class="hljs-string">"Challenge does not exist."</span>);
  <span class="hljs-keyword">let</span> challenge = Self::challenges(challenge_id);
  ensure!(challenge.resolved == <span class="hljs-literal">false</span>, <span class="hljs-string">"Challenge is already resolved."</span>);

  <span class="hljs-comment">// check commit stage length not passed</span>
  <span class="hljs-keyword">let</span> now = &lt;timestamp::Module&lt;T&gt;&gt;::get();
  ensure!(challenge.voting_ends &gt; now, <span class="hljs-string">"Commit stage length has passed."</span>);

  <span class="hljs-comment">// deduct the deposit for vote</span>
  &lt;token::Module&lt;T&gt;&gt;::lock(sender.clone(), deposit, challenge.listing_hash)?;

  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> poll_instance = Self::polls(challenge_id);
  <span class="hljs-comment">// based on vote value, increase the count of votes (for or against)</span>
  <span class="hljs-keyword">match</span> value {
    <span class="hljs-literal">true</span> =&gt; poll_instance.votes_for += deposit,
    <span class="hljs-literal">false</span> =&gt; poll_instance.votes_against += deposit,
  }

  <span class="hljs-comment">// create a new vote instance with the input params</span>
  <span class="hljs-keyword">let</span> vote_instance = Vote {
    value,
    deposit,
    claimed: <span class="hljs-literal">false</span>,
  };

  <span class="hljs-comment">// mutate polls collection to update the poll instance</span>
  &lt;Polls&lt;T&gt;&gt;::mutate(challenge_id, |poll| *poll = poll_instance);

  <span class="hljs-comment">// insert new vote into votes collection</span>
  &lt;Votes&lt;T&gt;&gt;::insert((challenge_id, sender.clone()), vote_instance);

  <span class="hljs-comment">// raise the event</span>
  Self::deposit_event(RawEvent::Voted(sender, challenge_id, deposit));
  runtime_io::print(<span class="hljs-string">"Vote created!"</span>);
  <span class="hljs-literal">Ok</span>(())
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="resolve"></a><a href="#resolve" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resolve</h3>
<p>Once an unchallenged listing is out of the apply stage period or a challenged listing is out of the commit period, the <code>resolve</code> function can be called on it. Anyone can call the resolve function as it does not involve any staking.</p>
<p>In the resolve function, we check for several conditions including,</p>
<ul>
<li>If the listing exists and whether it is in apply stage period</li>
<li>If a challenge exists for the listing and whether it is in commit stage period</li>
<li>If the votes are in favor of white-listing</li>
</ul>
<p>Based on the outcome of these checks we update the listing status to accepted or rejected by setting the <code>listing.whitelisted</code> value to true or false. We also raise the <code>Resolved</code> and <code>Accepted/Rejected</code> events.</p>
<p>In addition, we also update the token and reward values in the corresponding <code>Challenge</code> instance.</p>
<pre><code class="hljs css language-rust"><span class="hljs-comment">// resolves the status of a listing</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">resolve</span></span>(_origin, listing_id: <span class="hljs-built_in">u32</span>) -&gt; <span class="hljs-built_in">Result</span> {
  ensure!(&lt;ListingIndexHash&lt;T&gt;&gt;::exists(listing_id), <span class="hljs-string">"Listing not found."</span>);

  <span class="hljs-keyword">let</span> listing_hash = Self::index_hash(listing_id);
  <span class="hljs-keyword">let</span> listing = Self::listings(listing_hash);

  <span class="hljs-keyword">let</span> now = &lt;timestamp::Module&lt;T&gt;&gt;::get();
  <span class="hljs-keyword">let</span> challenge;
  <span class="hljs-keyword">let</span> poll;

  <span class="hljs-comment">// check if listing is challenged</span>
  <span class="hljs-keyword">if</span> listing.challenge_id &gt; <span class="hljs-number">0</span> {
    <span class="hljs-comment">// challenge</span>
    challenge = Self::challenges(listing.challenge_id);
    poll = Self::polls(listing.challenge_id);

    <span class="hljs-comment">// check commit stage length has passed</span>
    ensure!(challenge.voting_ends &lt; now, <span class="hljs-string">"Commit stage length has not passed."</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// no challenge</span>
    <span class="hljs-comment">// check if apply stage length has passed</span>
    ensure!(listing.application_expiry &lt; now, <span class="hljs-string">"Apply stage length has not passed."</span>);

    <span class="hljs-comment">// update listing status</span>
    &lt;Listings&lt;T&gt;&gt;::mutate(listing_hash, |listing| 
    {
      listing.whitelisted = <span class="hljs-literal">true</span>;
    });

    Self::deposit_event(RawEvent::Accepted(listing_hash));
    <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(());
  }

  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> whitelisted = <span class="hljs-literal">false</span>;

  <span class="hljs-comment">// mutate polls collection to update the poll instance</span>
  &lt;Polls&lt;T&gt;&gt;::mutate(listing.challenge_id, |poll| {
    <span class="hljs-keyword">if</span> poll.votes_for &gt;= poll.votes_against {
        poll.passed = <span class="hljs-literal">true</span>;
        whitelisted = <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> {
        poll.passed = <span class="hljs-literal">false</span>;
    }
  });

  <span class="hljs-comment">// update listing status</span>
  &lt;Listings&lt;T&gt;&gt;::mutate(listing_hash, |listing| {
    listing.whitelisted = whitelisted;
    listing.challenge_id = <span class="hljs-number">0</span>;
  });

  <span class="hljs-comment">// update challenge</span>
  &lt;Challenges&lt;T&gt;&gt;::mutate(listing.challenge_id, |challenge| {
    challenge.resolved = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> whitelisted == <span class="hljs-literal">true</span> {
      challenge.total_tokens = poll.votes_for;
      challenge.reward_pool = challenge.deposit + poll.votes_against;
    } <span class="hljs-keyword">else</span> {
      challenge.total_tokens = poll.votes_against;
      challenge.reward_pool = listing.deposit + poll.votes_for;
    }
  });

  <span class="hljs-comment">// raise appropriate event as per whitelisting status</span>
  <span class="hljs-keyword">if</span> whitelisted == <span class="hljs-literal">true</span> {
    Self::deposit_event(RawEvent::Accepted(listing_hash));
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// if rejected, give challenge deposit back to the challenger</span>
    &lt;token::Module&lt;T&gt;&gt;::unlock(challenge.owner, challenge.deposit, listing_hash)?;
    Self::deposit_event(RawEvent::Rejected(listing_hash));
  }

  Self::deposit_event(RawEvent::Resolved(listing_hash, listing.challenge_id));
  <span class="hljs-literal">Ok</span>(())
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="claim-reward"></a><a href="#claim-reward" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Claim reward</h3>
<p>Once a listing is resolved, voting rewards can be claimed using the <code>claim_reward</code> function. In this function, we check if the caller (origin) has voted on a particular challenge or not. We then check if the challenge has been resolved or not. Based on these checks, we calculate the reward for the origin and call the <code>unlock</code> function using the <code>token</code> module. We also update the <code>Vote</code> instance with the claimed status to true so that the same reward cannot be claimed again. Finally, we raise the <code>Claimed</code> event.</p>
<p>It is important to note that the <code>claim_reward</code> function takes a <code>challenge_id</code> as an input parameter rather than a listing (unlike previous functions). Finding the right <code>challenge_id</code> for a listing should be done beforehand.</p>
<pre><code class="hljs css language-rust"><span class="hljs-comment">// claim reward for a vote</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">claim_reward</span></span>(origin, challenge_id: <span class="hljs-built_in">u32</span>) -&gt; <span class="hljs-built_in">Result</span> {
  <span class="hljs-keyword">let</span> sender = ensure_signed(origin)?;

  <span class="hljs-comment">// ensure challenge exists and has been resolved</span>
  ensure!(&lt;Challenges&lt;T&gt;&gt;::exists(challenge_id), <span class="hljs-string">"Challenge not found."</span>);
  <span class="hljs-keyword">let</span> challenge = Self::challenges(challenge_id);
  ensure!(challenge.resolved == <span class="hljs-literal">true</span>, <span class="hljs-string">"Challenge is not resolved."</span>);

  <span class="hljs-comment">// get the poll and vote instances</span>
  <span class="hljs-comment">// reward depends on poll passed status and vote value</span>
  <span class="hljs-keyword">let</span> poll = Self::polls(challenge_id);
  <span class="hljs-keyword">let</span> vote = Self::votes((challenge_id, sender.clone()));

  <span class="hljs-comment">// ensure vote reward is not already claimed</span>
  ensure!(vote.claimed == <span class="hljs-literal">false</span>, <span class="hljs-string">"Vote reward has already been claimed."</span>);

  <span class="hljs-comment">// if winning party, calculate reward and transfer</span>
  <span class="hljs-keyword">if</span> poll.passed == vote.value {
        <span class="hljs-keyword">let</span> reward_ratio = challenge.reward_pool.checked_div(&amp;challenge.total_tokens).ok_or(<span class="hljs-string">"overflow in calculating reward"</span>)?;
        <span class="hljs-keyword">let</span> reward = reward_ratio.checked_mul(&amp;vote.deposit).ok_or(<span class="hljs-string">"overflow in calculating reward"</span>)?;
        <span class="hljs-keyword">let</span> total = reward.checked_add(&amp;vote.deposit).ok_or(<span class="hljs-string">"overflow in calculating reward"</span>)?;
        &lt;token::Module&lt;T&gt;&gt;::unlock(sender.clone(), total, challenge.listing_hash)?;

        Self::deposit_event(RawEvent::Claimed(sender.clone(), challenge_id));
    }

    <span class="hljs-comment">// update vote reward claimed status</span>
    &lt;Votes&lt;T&gt;&gt;::mutate((challenge_id, sender), |vote| vote.claimed = <span class="hljs-literal">true</span>);

  <span class="hljs-literal">Ok</span>(())
}
</code></pre>
<p>The core TCR flow is now complete with the <code>propose</code>, <code>challenge</code>, <code>vote</code>, <code>resolve</code>, and <code>claim_reward</code> functions. It can be further extended, as needed. Please note that what we have covered here is just a sample implementation of a subset of TCR functions. It is only for educational purposes and is not intended for real use-cases.</p>
<p>The code for the TCR runtime modules - <code>tcr</code> and <code>token</code> covered in this part of the guide, is available <a href="https://github.com/parity-samples/substrate-tcr/tree/master/runtime/src">here</a>.</p>
<p>In the next part of this guide, we will learn how we can call these runtime functions from a <code>reactjs</code> frontend using the <code>PolkadotJS</code> API.</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#step-1-setup-and-prerequisites">Step 1: Setup and prerequisites</a></li><li><a href="#step-2-module-trait-and-types">Step 2: Module trait and types</a></li><li><a href="#step-3-declaring-the-runtime-storage">Step 3: Declaring the runtime storage</a><ul class="toc-headings"><li><a href="#data-structures-for-on-chain-tcr-data">Data structures for on-chain TCR data</a></li><li><a href="#storage-declaration-using-the-decl_storage-macro">Storage declaration using the <code>decl_storage</code> macro</a></li><li><a href="#using-the-genesis-config">Using the genesis config</a></li></ul></li><li><a href="#step-4-declaring-events">Step 4: Declaring Events</a></li><li><a href="#step-5-module-business-logic">Step 5: Module business logic</a><ul class="toc-headings"><li><a href="#propose-a-listing">Propose a listing</a></li><li><a href="#challenge-and-vote">Challenge and Vote</a></li><li><a href="#resolve">Resolve</a></li><li><a href="#claim-reward">Claim reward</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/Substrate-logo.svg" alt="Substrate Developer Hub" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/quickstart/getting-started">Getting Started</a><a href="/en/tutorials">Tutorials</a><a href="https://crates.parity.io">Reference Docs</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="http://stackoverflow.com/questions/tagged/substrate" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://riot.im/app/#/room/!HzySYSaIhtyWrwiwEV:matrix.org">Riot Chat</a><a href="https://twitter.com/ParityTech" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="https://www.parity.io/blog/">Blog</a><a href="https://github.com/substrate-developer-hub/substrate-developer-hub.github.io">GitHub</a><a class="github-button" href="https://github.com/substrate-developer-hub/substrate-developer-hub.github.io" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2019 Parity Technologies</section></footer></div></body></html>