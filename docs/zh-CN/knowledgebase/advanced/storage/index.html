<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>存储 · Substrate Developer Hub</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Substrate 使用简单的键值存储数据，该存储的实现背后是经修改过，有数据库支撑的 Merkle 树。 所有 [更高层的存储抽象](../runtime/storage) 都是建立在这个简单的键值存储之上。"/><meta name="docsearch:language" content="zh-CN"/><meta property="og:title" content="存储 · Substrate Developer Hub"/><meta property="og:type" content="website"/><meta property="og:url" content="https://substrate-developer-hub.github.io//"/><meta property="og:description" content="Substrate 使用简单的键值存储数据，该存储的实现背后是经修改过，有数据库支撑的 Merkle 树。 所有 [更高层的存储抽象](../runtime/storage) 都是建立在这个简单的键值存储之上。"/><meta property="og:image" content="https://substrate-developer-hub.github.io/img/substrate-dev-hub-card.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://substrate-developer-hub.github.io/img/substrate-dev-hub-card.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script><script type="text/javascript" src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script type="text/javascript" src="/js/load.js"></script><script type="text/javascript" src="/js/past-seminars.js"></script><script type="text/javascript" src="/js/config.js" defer=""></script><script type="text/javascript" src="/js/klaro.min.js" defer=""></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/prism.css"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zh-CN"><img class="logo" src="/img/Substrate-logo.svg" alt="Substrate Developer Hub"/><h2 class="headerTitleWithLogo">Substrate Developer Hub</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/zh-CN/tutorials" target="_self">教程</a></li><li class="siteNavGroupActive"><a href="/docs/zh-CN/" target="_self">知识库</a></li><li class=""><a href="https://substrate.dev/recipes/" target="_self">进阶菜谱</a></li><li class=""><a href="https://substrate.dev/substrate-how-to-guides/" target="_self">How-to Guides</a></li><li class=""><a href="https://substrate.dev/rustdocs/" target="_self">Reference</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>简体中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/knowledgebase/advanced/storage">English</a></li><li><a href="https://crowdin.com/project/substrate-developer-hub" target="_blank" rel="noreferrer noopener">协助翻译</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>进阶</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">开始<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/">总览</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/getting-started/architecture">Architecture</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/getting-started/">安装</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/getting-started/windows-users">在 Windows 系统开始</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/getting-started/glossary">词汇表</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Substrate Key Concepts<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/">Runtime</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/extrinsics">Extrinsics</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/account-abstractions">账户摘要</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/tx-pool">交易池</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/session-keys">会话密钥</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/weight">Transaction Weights</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/off-chain-features">链下功能</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Runtime 开发<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/pallets">Pallets</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/frame">FRAME</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/macros">宏</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/metadata">元数据</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/storage">Storage</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/origin">来源 (Origin)</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/execution">Execution</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/events">Events</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/errors">Errors</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/fees">Transaction Fees and Weights</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/benchmarking">Benchmarking</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/debugging">调试</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/tests">Tests</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/randomness">链上随机生成</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/upgrades">Upgrades</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">智能合约<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/">总览</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/contracts-pallet">合约 (Contracts) 模块</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/evm-pallet">EVM 模块</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/faq">F.A.Q.</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">整合<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/polkadot-js">Polkadot-JS</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/libraries">客户端库</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/chain-spec">链规范</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/subkey">Subkey</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/memory-profiling">内存分析</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/try-runtime">Try Runtime</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">进阶<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/account-info">Account Information</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/codec">SCALE 编解码器</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/consensus">共识机制</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/block-import">区块导入过程</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/executor">Runtime Executor</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/cryptography">密码学</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/storage">存储</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/ss58-address-format">SS58 地址格式</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/no-hash-collections">Hash Collections</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">贡献<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/contribute/help-translate">协助翻译</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/substrate-developer-hub/zh-CN" target="_blank" rel="noreferrer noopener">Translate</a><h1 id="__docusaurus" class="postHeaderTitle">存储</h1></header><article><div><span><p>Substrate 使用简单的键值存储数据，该存储的实现背后是经修改过，有数据库支撑的 Merkle 树。 所有 <a href="../runtime/storage">更高层的存储抽象</a> 都是建立在这个简单的键值存储之上。</p>
<h2><a class="anchor" aria-hidden="true" id="键值数据库"></a><a href="#键值数据库" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>键值数据库</h2>
<p>Substrate 用 <a href="https://rocksdb.org/">RocksDB</a> 实现了它的存储数据库，RocksDB 是一个可快速并作持久储存的键值存储。 它还支持一个试验中的 <a href="https://github.com/paritytech/parity-db">Parity DB</a>。</p>
<p>该数据库用于 Substrate 所有需要持久化存储的组件，例如：</p>
<ul>
<li>Substrate 客户端</li>
<li>Substrate 轻客户端</li>
<li>链下工作机</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="trie-抽象"></a><a href="#trie-抽象" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Trie 抽象</h2>
<p>使用简单的键值存储的一个好处是，你能够很容易地在它上面抽象出存储结构。</p>
<p>Substrate 使用来自 <a href="https://github.com/paritytech/trie"><code>paritytech/trie</code></a> 的 Base-16 修改后的 Merkle Patricia 树 (&quot;trie&quot;)，来提供一个 trie 结构。其内容可以修改并且其根哈希可以有效地重新计算。</p>
<p>Tries 结构允许高效存储和历史区块的状态共享。 Trie 根是 trie 内数据的表征，也就是说两个具有不同数据的 tire 一定会具有不同的根。 因此，两个区块链节点可以通过比较它们的 trie 根来轻松验证它们是否具有相同的状态。</p>
<p>访问 trie 数据的费用非常高。 每次读取操作都需要 O(log N) 时间，其中 N 是存储在 trie 中的数据的数量。 为了减轻查询费用，我们使用了键值缓存。</p>
<p>所有 trie 节点都存储在数据库中，部分 trie 状态可以被删剪掉，即当键值对超出非存档节点的删剪范围时，键值对会从存储空间中被删除掉。 出于性能原因，我们没用 <a href="http://en.wikipedia.org/wiki/Reference_counting">引用计数法</a>。</p>
<h3><a class="anchor" aria-hidden="true" id="状态树"></a><a href="#状态树" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>状态树</h3>
<p>Substrate 链都有一个主状态树，叫 State trie，而它的根哈希存储于每个区块头中。 这用于可容易验证区块链的状态，并为轻客户端可作验证证据打下基础。</p>
<p>这个 trie 只存储主链 (canonical chain) 中的内容，而不存储分叉链 (forks) 的。 There is a separate <a href="https://substrate.dev/rustdocs/latest/sc_state_db/index.html"><code>state_db</code> layer</a> that maintains the trie state with references counted in memory for all that is non-canonical.</p>
<h3><a class="anchor" aria-hidden="true" id="子状态树"></a><a href="#子状态树" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>子状态树</h3>
<p>Substrate 还提供了一个 API 来生成一个有着根哈希的新子状态树 (Child Trie)，而这根哈希可供 runtime 使用。</p>
<p>子状态树与主状态树基本相同， 唯一区别是子状态树的根是作为节点在主状态树中储存并更新的，而不是作为区块头。 由于他们的头是主状态树的一部分，因此要验证包含子状态树的完整状态仍然是很容易的。</p>
<p>当你希望拥有独立的状态树和根哈希、并能对该树中的特定内容作验证时，子状态树是很有用的。 因为一个状态树的子部分并没有根哈希，具有这方面的要求就需要用到子状态树来满足。</p>
<h2><a class="anchor" aria-hidden="true" id="查询存储"></a><a href="#查询存储" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查询存储</h2>
<p>Substrate 区块链对外开放了远端过程调用 (RPC) 服务，该服务可用于查询 runtime 的存储。 当您使用 Substrate RPC 访问一个存储项时，您只需要提供与该存储项关联的 <a href="#Key-Value-Database">键</a>。 <a href="../runtime/storage">Substrate 的 Runtime 存储 APIs</a> 开放了数种存储项类型；请继续阅读来了解如何为不同类型的存储项计算其存储键。</p>
<h3><a class="anchor" aria-hidden="true" id="存储键"></a><a href="#存储键" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>存储键</h3>
<p>To calculate the key for a simple <a href="../runtime/storage#storage-value">Storage Value</a>, take the <a href="https://github.com/Cyan4973/xxHash">TwoX 128 hash</a> of the name of the module that contains the Storage Value and append to it the TwoX 128 hash of the name of the Storage Value itself. For example, the <a href="https://substrate.dev/rustdocs/latest/pallet_sudo/index.html">Sudo</a> pallet exposes a Storage Value item named <a href="https://substrate.dev/rustdocs/latest/pallet_sudo/struct.Module.html#method.key"><code>Key</code></a>：</p>
<pre><code class="hljs"><span class="token function">twox_128</span><span class="token punctuation">(</span><span class="token string">"Sudo"</span><span class="token punctuation">)</span>                   <span class="token operator">=</span> <span class="token string">"0x5c0d1176a568c1f92944340dbfed9e9c"</span>
<span class="token function">twox_128</span><span class="token punctuation">(</span><span class="token string">"Key"</span><span class="token punctuation">)</span>                    <span class="token operator">=</span> <span class="token string">"0x530ebca703c85910e7164cb7d1c9e47b"</span>
<span class="token function">twox_128</span><span class="token punctuation">(</span><span class="token string">"Sudo"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">twox_128</span><span class="token punctuation">(</span><span class="token string">"Key"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"0x5c0d1176a568c1f92944340dbfed9e9c530ebca703c85910e7164cb7d1c9e47b"</span>
</code></pre>
<p>如果 <code>Alice</code> 账号是 sudo 用户，读取 Sudo 模块的 <code>Key</code> 存储值的 RPC 请求和响应可表示为：</p>
<pre><code class="hljs"><span class="token function">state_getStorage</span><span class="token punctuation">(</span><span class="token string">"0x5c0d1176a568c1f92944340dbfed9e9c530ebca703c85910e7164cb7d1c9e47b"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d"</span>
</code></pre>
<p>在这种情况下，返回的值 (<code>&quot;0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;</code>) 是Alice的 <a href="./codec">SCALE</a> -编码账户 ID (<code>5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY</code>)。</p>
<p>You may have noticed that the <a href="../runtime/storage#cryptographic-hashing-algorithms">non-cryptographic</a> TwoX 128 hash algorithm is used to generate Storage Value keys. 是因为在这里我们不需要付出加密哈希函数带来的性能成本，因为这哈希函数的输入 (即模块和存储项的名称) 是由 Runtime 开发人员决定，而不是潜在恶意用户来决定的。</p>
<h3><a class="anchor" aria-hidden="true" id="存储映射键"></a><a href="#存储映射键" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>存储映射键</h3>
<p>Like Storage Values, the keys for <a href="../runtime/storage#storage-maps">Storage Maps</a> are equal to the TwoX 128 hash of the name of the module that contains the map prepended to the TwoX 128 hash of the name of the Storage Map itself. 要从映射中检索一个值，只需将映射在存储的键，再加上该映射里的键的哈希值即可。 对于有两个键的映射 (双映射存储)，将第一个映射键的哈希值和第二个映射键的哈希值附加到双映射存储的键上。 Like Storage Values, Substrate will use the TwoX 128 hashing algorithm for the module and Storage Map names, but you will need to make sure to use the correct <a href="../runtime/storage#hashing-algorithms">hashing algorithm</a> (the one that was declared in <a href="../runtime/storage#declaring-storage-items">the <code>decl_storage</code> macro</a>) when determining the hashed keys for the elements in a map.</p>
<p>下面是一个例子，演示从名为 &quot;Balances &quot; 模块中查询名为 <code>FreeBalance</code> 的存储映射，来查询 <code>Alice</code> 的账户余额。 In this example, the <code>FreeBalance</code> map is using <a href="../runtime/storage#transparent-hashing-algorithms">the transparent Blake2 128 Concat hashing algorithm</a>:</p>
<pre><code class="hljs"><span class="token function">twox_128</span><span class="token punctuation">(</span><span class="token string">"Balances"</span><span class="token punctuation">)</span>                                             <span class="token operator">=</span> <span class="token string">"0xc2261276cc9d1f8598ea4b6a74b15c2f"</span>
<span class="token function">twox_128</span><span class="token punctuation">(</span><span class="token string">"FreeBalance"</span><span class="token punctuation">)</span>                                          <span class="token operator">=</span> <span class="token string">"0x6482b9ade7bc6657aaca787ba1add3b4"</span>
<span class="token function">scale_encode</span><span class="token punctuation">(</span><span class="token string">"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d"</span>

<span class="token function">blake2_128_concat</span><span class="token punctuation">(</span><span class="token string">"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"0xde1e86a9a8c739864cf3cc5ec2bea59fd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d"</span>

<span class="token function">state_getStorage</span><span class="token punctuation">(</span><span class="token string">"0xc2261276cc9d1f8598ea4b6a74b15c2f6482b9ade7bc6657aaca787ba1add3b4de1e86a9a8c739864cf3cc5ec2bea59fd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"0x0000a0dec5adc9353600000000000000"</span>
</code></pre>
<p>存储查询返回的值 (上面例子中的 <code>&quot;0x0000a0dec5adc9353600000000000000&quot;</code>) 是 Alice 账户余额的 <a href="./codec">SCALE</a>-编码值 (本例中的 <code>&quot;1000000000000000000000&quot;</code>)。 请注意，在对 Alice 的账户 ID 进行哈希之前，它必须是 SCALE 编码的。 也请注意，<code>blake2_128_concat</code> 函数的输出由 32 个十六进制字符组成，后面跟着函数的输入参数。 This is because the Blake2 128 Concat is <a href="../runtime/storage#transparent-hashing-algorithms">a transparent hashing algorithm</a>. 尽管上面的例子可能会让这个特性显得多余，但当我们需要遍历一个映射中的所有键时 (而不只是检索与单个键相关的值)，其作用就变得明显。 能遍历一个映射中的所有键，是一个让 <em>开发者</em> 接受去用它，而实现 UI 时又常常要用到的基本需求：首先，用户会看到映射中的所有键，然后用户可选择他们感兴趣的键，并同时在映射中查询该键的更多细节。 下面是另一个例子，使用同样的存储映射（一个名为 <code>FreeBalances</code> 的映射，在 &quot;Balances&quot; 模块中使用 Blake2 128 Concat 哈希算法），该例将演示使用 Substrate RPC 通过 <code>state_getKeys</code> 函数查询某个存储映射所有的键。</p>
<pre><code class="hljs"><span class="token function">twox_128</span><span class="token punctuation">(</span><span class="token string">"Balances"</span><span class="token punctuation">)</span>                                      <span class="token operator">=</span> <span class="token string">"0xc2261276cc9d1f8598ea4b6a74b15c2f"</span>
<span class="token function">twox_128</span><span class="token punctuation">(</span><span class="token string">"FreeBalance"</span><span class="token punctuation">)</span>                                   <span class="token operator">=</span> <span class="token string">"0x6482b9ade7bc6657aaca787ba1add3b4"</span>

<span class="token function">state_getKeys</span><span class="token punctuation">(</span><span class="token string">"0xc2261276cc9d1f8598ea4b6a74b15c2f6482b9ade7bc6657aaca787ba1add3b4"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">"0xc2261276cc9d1f8598ea4b6a74b15c2f6482b9ade7bc6657aaca787ba1add3b4de1e86a9a8c739864cf3cc5ec2bea59fd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d"</span><span class="token punctuation">,</span>
  <span class="token string">"0xc2261276cc9d1f8598ea4b6a74b15c2f6482b9ade7bc6657aaca787ba1add3b432a5935f6edc617ae178fef9eb1e211fbe5ddb1579b72e84524fc29e78609e3caf42e85aa118ebfe0b0ad404b5bdd25f"</span><span class="token punctuation">,</span>
  <span class="token punctuation">...</span>
<span class="token punctuation">]</span>
</code></pre>
<p>Substrate RPC 的 <code>state_getKeys</code> 函数返回的序列中的每个值，都可作为参数直接传入 RPC <code>state_getStorage</code> 函数来使用。 事实上，上面例子列表中的第一个值，等于再前一个例子中 <code>state_getStorage</code> 查询所使用的输入 (用于查找 <code>Alice</code> 余额的那个)。 因为这些键所属的映射使用了透明的哈希算法生成其键，所以可确定序列中与第二个值相关联的账户。 请注意序列中的每个值都是以相同的 64 个字符的十六进制值开头；这是因为每个值都代表了同一个映射中的一个键，而这个映射是通过连接两个 TwoX 128 哈希值来确定的，每个哈希值都是 128 位或 32 位的十六进制字符。 丢弃序列中第二个值的该部分内容后，你会得到 <code>0x32a5935f6edc617ae178fef9eb1e211fbe5ddb1579b72e84524fc29e78609e3caf42e85aa118ebfe0b0ad404b5bdd25f</code>。</p>
<p>你在前面的例子中理解到，这值代表了某个 <a href="./codec">SCALE</a>- 编码账户 ID 的 Blake2 128 Concat 哈希值。 这 Blake 128 Concat 哈希算法包括将哈希算法的输入追加 (连缀) 到其 Blake 128 哈希中。 这意味着 Blake2 128 Concat 哈希的前128位 (或 32 个十六进制字符) 代表 Blake2 128 哈希，而其余部分代表传递给 Blake2 128 哈希算法的值。 在这例子中，去掉代表 Blake2 128 哈希的前 32 个十六进制字符 (即 <code>0x32a5935f6edc617ae178fef9eb1e211f</code>) 后，剩下的是十六进制值 <code>0xbe5ddb1579b72e84524fc29e78609e3caf42e85aa118ebfe0b0ad404b5bdd25f</code>，就是一个 <a href="./codec">SCALE</a> 编码的账户 ID。 对这个值进行解码，得到的结果是 <code>5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY</code>，这就是大家熟悉的 <code>Alice_Stash</code> 的账号 ID。</p>
<h2><a class="anchor" aria-hidden="true" id="runtime-存储接口"></a><a href="#runtime-存储接口" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Runtime 存储接口</h2>
<p>Substrate's <a href="https://substrate.dev/rustdocs/latest/frame_support/index.html">FRAME Support crate</a> provides utilities for generating unique, deterministic keys for your runtime's storage items. These storage items are placed in the <a href="#trie-abstraction">state trie</a> and are accessible by <a href="#querying-storage">querying the trie by key</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="后续步骤"></a><a href="#后续步骤" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>后续步骤</h2>
<h3><a class="anchor" aria-hidden="true" id="进一步学习"></a><a href="#进一步学习" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>进一步学习</h3>
<ul>
<li>学习如何在 Substrate Runtime 模块中添加 <a href="../runtime/storage">存储项</a> 。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="参考文档"></a><a href="#参考文档" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参考文档</h3>
<ul>
<li>Visit the reference docs for <a href="https://substrate.dev/rustdocs/latest/trie_db/trait.Trie.html"><code>paritytech/trie</code></a> 的文档。</li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/zh-CN/knowledgebase/advanced/cryptography"><span class="arrow-prev">← </span><span>密码学</span></a><a class="docs-next button" href="/docs/zh-CN/knowledgebase/advanced/ss58-address-format"><span>SS58 地址格式</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#键值数据库">键值数据库</a></li><li><a href="#trie-抽象">Trie 抽象</a><ul class="toc-headings"><li><a href="#状态树">状态树</a></li><li><a href="#子状态树">子状态树</a></li></ul></li><li><a href="#查询存储">查询存储</a><ul class="toc-headings"><li><a href="#存储键">存储键</a></li><li><a href="#存储映射键">存储映射键</a></li></ul></li><li><a href="#runtime-存储接口">Runtime 存储接口</a></li><li><a href="#后续步骤">后续步骤</a><ul class="toc-headings"><li><a href="#进一步学习">进一步学习</a></li><li><a href="#参考文档">参考文档</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/Substrate-logo.svg" alt="Substrate Developer Hub" width="66" height="58"/></a><div><h5>开发者中心</h5><a href="/zh-CN/tutorials">教程</a><a href="/docs/zh-CN/">知识库</a><a href="https://substrate.dev/recipes/">进阶菜谱</a><a href="https://substrate.dev/substrate-how-to-guides">How-to Guides</a><a href="https://substrate.dev/rustdocs">API 文档</a><a href="https://playground.substrate.dev/">Playground</a></div><div><h5>社区</h5><a href="/zh-CN/community">社区主页</a><a href="/zh-CN/newsletter">通讯</a><a href="https://matrix.to/#/#substrate-technical:matrix.org">Substrate 技术聊天室</a><a href="/zh-CN/seminar">Substrate 研讨会</a><a href="http://stackoverflow.com/questions/tagged/substrate" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://twitter.com/substrate_io" target="_blank" rel="noreferrer noopener">推特</a><a href="https://www.meetup.com/parity/" target="_blank" rel="noreferrer noopener">聚会活动</a></div><div><h5>更多</h5><a href="https://www.substrate.io/builders-program/">Substrate Builders 计划</a><a href="https://www.parity.io/blog/">Blog</a><a href="https://github.com/paritytech/substrate">Substrate GitHub</a><a href="https://github.com/substrate-developer-hub/">开发者中心 GitHub</a><a href="https://www.parity.io/privacy/">隐私政策</a><a href="/terms">使用条款</a><a href="#" id="cookie-settings">Cookie 设置<script>
                var cookieSettings = document.getElementById('cookie-settings');
                cookieSettings.onclick = function() {
                  return klaro.show();
                };
              </script></a></div></section><section class="copyright">Copyright © 2021 Parity Technologies</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '5cd09916f4ba4c283b2d45ee7386fc34',
                indexName: 'substrate',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:zh-CN"]}
              });
            </script></body></html>