<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>共识机制 · Substrate Developer Hub</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="区块链节点使用共识引擎来商定区块链的状态。 本文涵盖了区块链系统的共识机制的基本知识点：共识算法如何在Substrate框架中与 Runtime 交互，及框架内所包含的几个共识引擎。"/><meta name="docsearch:language" content="zh-CN"/><meta property="og:title" content="共识机制 · Substrate Developer Hub"/><meta property="og:type" content="website"/><meta property="og:url" content="https://substrate-developer-hub.github.io//"/><meta property="og:description" content="区块链节点使用共识引擎来商定区块链的状态。 本文涵盖了区块链系统的共识机制的基本知识点：共识算法如何在Substrate框架中与 Runtime 交互，及框架内所包含的几个共识引擎。"/><meta property="og:image" content="https://substrate-developer-hub.github.io/img/substrate-dev-hub-card.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://substrate-developer-hub.github.io/img/substrate-dev-hub-card.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/js/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script type="text/javascript" src="/js/load.js"></script><script type="text/javascript" src="/js/redirect-next.js"></script><script type="text/javascript" src="/js/config.js" defer=""></script><script type="text/javascript" src="/js/klaro.min.js" defer=""></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/prism.css"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zh-CN"><img class="logo" src="/img/Substrate-logo.svg" alt="Substrate Developer Hub"/><h2 class="headerTitleWithLogo">Substrate Developer Hub</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/zh-CN/tutorials" target="_self">教程</a></li><li class="siteNavGroupActive"><a href="/docs/zh-CN/" target="_self">知识库</a></li><li class=""><a href="https://substrate.dev/recipes/" target="_self">进阶菜谱</a></li><li class=""><a href="https://substrate.dev/rustdocs/" target="_self">API 文档</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>简体中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/knowledgebase/advanced/consensus">English</a></li><li><a href="/docs/zh-HK/knowledgebase/advanced/consensus">繁體中文</a></li><li><a href="https://crowdin.com/project/substrate-developer-hub" target="_blank" rel="noreferrer noopener">协助翻译</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>进阶</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">开始<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/">总览</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/getting-started/">安装</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/getting-started/windows-users">在 Windows 系统开始</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/getting-started/glossary">词汇表</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">学习 Substrate<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/extrinsics">Extrinsics</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/tx-pool">交易池</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/account-abstractions">账户摘要</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/session-keys">会话密钥</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/weight">交易权重</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/learn-substrate/off-chain-features">链下功能</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Runtime<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/">Runtime 总览</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/primitives">Runtime 的基本类型</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/frame">FRAME</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/pallets">Pallets</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/macros">Runtime宏</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/metadata">Runtime 元数据</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/storage">Runtime 存储</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/origin">Runtime 来源</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/execution">Runtime 执行流程</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/events">Runtime事件</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/errors">Runtime 错误</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/fees">交易费用</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/off-chain-workers">链下工作机</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/debugging">调试</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/tests">Runtime 测试</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/randomness">链上随机生成</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/runtime/upgrades">Runtime 升级</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">智能合约<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/overview">总览</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/">ink! 智能合约</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/ink-fundamentals">ink! 概念</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/ink-development">ink! 开发</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/evm-pallet">EVM 模块</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/smart-contracts/faq">ink! 常问问题</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">整合<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/polkadot-js">Polkadot-JS</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/libraries">客户端库</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/chain-spec">链描述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/subkey">Subkey 工具</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/integrate/memory-profiling">内存分析</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">进阶<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/codec">SCALE 编解码器</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/consensus">共识机制</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/block-import">区块导入过程</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/executor">执行器</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/cryptography">密码学</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/storage">存储</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/knowledgebase/advanced/ss58-address-format">SS58 地址格式</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">贡献<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/zh-CN/contribute/help-translate">协助翻译</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/substrate-developer-hub/zh-CN" target="_blank" rel="noreferrer noopener">Translate</a><h1 id="__docusaurus" class="postHeaderTitle">共识机制</h1></header><article><div><span><p>区块链节点使用共识引擎来商定区块链的状态。 本文涵盖了区块链系统的共识机制的基本知识点：共识算法如何在Substrate框架中与 Runtime 交互，及框架内所包含的几个共识引擎。</p>
<h2><a class="anchor" aria-hidden="true" id="状态机和冲突"></a><a href="#状态机和冲突" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>状态机和冲突</h2>
<p>区块链的 Runtime 就是一个 <a href="https://en.wikipedia.org/wiki/Finite-state_machine">状态机</a>。 它有一些内部状态和状态迁移函数，使得它可从当前状态迁移到下一个状态。 在大多数 Runtime 中，某些状态可以有多个有效迁移函数迁移到多个未来状态，但只能从中选取一个进行迁移。</p>
<p>区块链必须对下述内容达成一致：</p>
<ul>
<li>初始状态，也叫做“创世区块”，</li>
<li>一系列状态迁移，每个迁移被称为“区块”，以及</li>
<li>一个最终(当前) 状态。</li>
</ul>
<p>为了在转换之后对结果状态达成一致，区块链<a href="../runtime/index">状态迁移函数</a> 里的所有操作必须是具备确定性的（ deterministic）。</p>
<h2><a class="anchor" aria-hidden="true" id="冲突排除"></a><a href="#冲突排除" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>冲突排除</h2>
<p>在中心化系统中，中央服务器通过先后顺序从互斥的备选状态转换事务中进行选择，在冲突发生时选择第一个备选方案。 在去中心化系统中，不同节点可能会看到不同的交易顺序，因此它们必须使用一套更加精心设计的方法来剔除交易。 更加复杂的是，区块链网络力求容错, 这意味着即使一些参与者不遵守规则，整个网络也应继续提供一致的数据。</p>
<p>区块链将交易分批纳入区块，并采取一些手段来选择由哪个参与者拥有提交区块的权力。 比如说，在用工作量证明的链中，第一个找到有效工作量证明的节点就有权提交区块到链上。</p>
<p>Substrate 提供了几个区块生成算法，也允许您创建自己的算法：</p>
<ul>
<li>Aura (轮询调度)</li>
<li>BABE (基于时隙)</li>
<li>工作量证明</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="分叉选择规则"></a><a href="#分叉选择规则" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分叉选择规则</h2>
<p>先说基础，一个区块包含一个区块头和一系列的 <a href="../learn-substrate/extrinsics">外部交易</a>。 区块头必须包含一个对父区块的引用，以至可一直追溯回到创世区块。 当两个区块引用到同一个父区块时，就表示出现分叉。 而分叉是必须解决的，这样才有一条标准规范的链。</p>
<p>分叉选择规则是一个在区块链中选择应当被延续的“最佳”链的算法。 Substrate 将这概念展露在 <a href="https://substrate.dev/rustdocs/v2.0.0/sp_consensus/trait.SelectChain.html"><code>SelectChain</code> Trait</a>.</p>
<p>Substrate 允许你编写自定义分叉选择规则，或者从给定的规则中选择一个。 例如：</p>
<h3><a class="anchor" aria-hidden="true" id="最长链规则"></a><a href="#最长链规则" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>最长链规则</h3>
<p>最长链规则简单来说，就是把最长的链作为最佳链。 Substrate 把选择链的规则放在 <a href="https://substrate.dev/rustdocs/v2.0.0/sc_consensus/struct.LongestChain.html"><code>LongestChain</code> 结构体</a>。 GRANDPA 使用最长链规则进行投票。</p>
<p><img src="/docs/assets/consensus-longest-chain.png" alt="最长链规则"></p>
<h3><a class="anchor" aria-hidden="true" id="ghost-规则"></a><a href="#ghost-规则" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GHOST 规则</h3>
<p>GHOST（The Greedy Heaviest Observed SubTree，贪婪最重可观察子树）规则是指从创世区块开始，每一个分叉都是通过递归地选择包含最多区块的分支来解决的。</p>
<p><img src="/docs/assets/consensus-ghost.png" alt="GHOST 规则"></p>
<h2><a class="anchor" aria-hidden="true" id="区块生成"></a><a href="#区块生成" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>区块生成</h2>
<p>区块链网络中的一些节点可以生成新区块，该过程称为“创建区块”。 究竟哪个节点可以创建区块，取决于你使用什么样的共识引擎。 在中心化网络中，可以是由单个节点来创建所有的区块。但在完全无许可网络中，必须要使用一种算法来选择每个区块的创建者。</p>
<h3><a class="anchor" aria-hidden="true" id="工作量证明"></a><a href="#工作量证明" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>工作量证明</h3>
<p>在类似比特币这样的工作量证明系统中，任何节点在任意时刻都可以生成区块，只要它成功解决了一个计算密集型难题。 解决难题需要花费CPU时间，因此矿工只能使用他们的计算资源来生成区块。 Substrate 提供一个工作量证明区块生成引擎。</p>
<h3><a class="anchor" aria-hidden="true" id="时隙"></a><a href="#时隙" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>时隙</h3>
<p>基于时隙的共识算法必须包含一组已知的、允许生成区块的验证者的集合。 时间被分成离散的时隙，在每个时隙中只有一部分验证人节点可生成一个区块。 指定哪些验证者可以创作区块的方法因共识引擎的不同而不同。 Substrate 提供 Aura 和 Babe，这两者都是基于时隙的区块生成引擎。</p>
<h2><a class="anchor" aria-hidden="true" id="最终确定性"></a><a href="#最终确定性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>最终确定性</h2>
<p>不管在什么系统中，用户都想知道他们的交易是什么时候确定完成的，区块链也一样。 在一些传统系统中，当收据交出或文件签名时，就是最终确定的了。</p>
<p>如果使用前述的区块创建模式和分叉选择规则，交易是永远不能最终确定的。 总是有机会出现一个更长的(或更重的) 链，从而回滚你的交易。 当然，在某个特定区块之上构建的区块越多，就越不可能回滚。 这样的话，采用适当的分叉选择规则的区块生成算法只提供了概率上的最终确定性。</p>
<p>当需要明确无误的最终确定性时，可以在区块链逻辑中添加一个最终确定性小工具。 固定验证人集合的成员为区块的最终性进行投票，当某个区块拥有足够数量的投票时，该区块将被视为是最终确定的。 在大多数系统中，这一阈值为2/3。 以这种方式确定的区块无法被回滚，除非采用像硬分叉这样的外部协调手段。</p>
<blockquote>
<p>一些共识机制将区块生成和最终确定性组合在一起，就像这样：区块最终确定是区块生成流程的一部分，除非块 <code>N</code> 已最终确定，否则新的 <code>N+1</code> 块无法创建。 但是 Substrate 分离了这两个过程，允许你使用任何具备概率上保证最终性的区块生成引擎，或者将其与一个最终确定性配件结合起来以具备完全的的最终确定性。</p>
</blockquote>
<p>在使用最终确定性小工具的系统中，必须修改分叉选择规则以考虑最终确定性博弈的结果。 例如，节点应该选取包含有最近的最终确定区块的最长链，而不是简单地选择最长链。</p>
<h2><a class="anchor" aria-hidden="true" id="substrate中的共识"></a><a href="#substrate中的共识" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Substrate中的共识</h2>
<p>Substrate 框架配备了几个共识引擎，可以提供区块创建或者最终确定性。 本文简要概述了Substrate自身提供的共识引擎。 我们欢迎开发者提供自己的共识算法。</p>
<h3><a class="anchor" aria-hidden="true" id="aura"></a><a href="#aura" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aura</h3>
<p><a href="https://substrate.dev/rustdocs/v2.0.0/sc_consensus_aura/index.html">AURA</a> 提供了基于时隙的区块生成机制。 在Aura中，通过一组已知的权威成员来生成区块。</p>
<h3><a class="anchor" aria-hidden="true" id="babe"></a><a href="#babe" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BABE</h3>
<p><a href="https://substrate.dev/rustdocs/v2.0.0/sc_consensus_babe/index.html">BABE</a> 也提供了基于时隙，通过一组已知的验证人节点来生成区块的方法。 在这些方面，它类似于Aura。 不同于AURA, 时隙分配是基于对可验证随机函数(VRF) 的计算。 在每一个<em>时段 (epoch)</em>中，每个验证节点得到一个权重。这个时段被分解为若干时隙，而验证节点在每个时隙里计算自己的VRF。 当一个验证者在该时隙的VRF输出值小于它的权重时，就可以创建一个区块。</p>
<p>由于同一个时隙中可能有多个验证者能够生成区块，分叉在BABE中要比Aura更常见，即使在良好的网络条件下也是常见的。</p>
<p>Substrate的BABE实现也提供了一个备用机制，用于在某个时隙中没有验证者被选中的情形。 分配这些“次要”时隙使得 BABE 实现了恒定的区块时间。</p>
<h3><a class="anchor" aria-hidden="true" id="工作量证明-1"></a><a href="#工作量证明-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>工作量证明</h3>
<p><a href="https://substrate.dev/rustdocs/v2.0.0/sc_consensus_pow/index.html">工作量证明</a> 的区块生成不是基于时隙，也不需要已知的验证节点群。 在工作量证明中，任何人可以在任何时间生成一个区块，只要他们能解决一个计算密集性问题（通常如哈希原像搜索）。 通过调整这个问题的难度，可以统计性的实现出块的目标时间。</p>
<h3><a class="anchor" aria-hidden="true" id="grandpa"></a><a href="#grandpa" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GRANDPA</h3>
<p><a href="https://substrate.dev/rustdocs/v2.0.0/sc_finality_grandpa/index.html">GRANDPA</a> 会最终确认区块。 它有一个类似BABE的权威验证人集合。 然而 GRANDPA 并不生产区块； 它只是监听其它共识引擎（如上面讨论的三个引擎）所产生的区块。 GRANDPA 验证人对 <em>链</em>，而不是<em>区块</em>进行投票。换言之，当验证人对他们认为 &quot;最优&quot; 的区块投票时，他们同时也对该链前面的所有区块作了投票。 一旦超过 2/3 的 GRANDPA 验证人给某一个特定的区块投了票，这个区块就被视为是最终确定的。</p>
<h3><a class="anchor" aria-hidden="true" id="与runtime协作"></a><a href="#与runtime协作" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>与Runtime协作</h3>
<p>我们已经描述了完全在 runtime 之外就可以正常工作的最简单的静态共识算法。 然而，许多共识引擎通过添加需要与 runtime 协作的特性而变得更强大。 这方面的例子包括难度可调整的工作量证明、验证人轮换的权威证明，以及基于质押权重的权益证明网络。</p>
<p>为了实现这些共识机制功能，Substrate 有 <a href="https://substrate.dev/rustdocs/v2.0.0/sp_runtime/enum.DigestItem.html"><code>DigestItem</code></a>, 就是从保存着共识机制的节点外部与 Runtime 相互传送的信息。</p>
<h2><a class="anchor" aria-hidden="true" id="进一步学习"></a><a href="#进一步学习" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>进一步学习</h2>
<p>由于BABE和GRANDPA都将被用于Polkadot网络，Web3基金会提供了研究级别的算法介绍。</p>
<ul>
<li><a href="https://research.web3.foundation/en/latest/polkadot/block-production/Babe.html">BABE研究</a></li>
<li><a href="https://research.web3.foundation/en/latest/polkadot/finality.html">GRANDPA 研究</a></li>
</ul>
<p>包括 GRANDPA 在内的完全最终性算法至少需要 <code>2f + 1</code> 个可靠节点， 其中 <code>f</code> 是错误或恶意节点的数量。 查看这些开创性的论文 <a href="https://lamport.azurewebsites.net/pubs/reaching.pdf">Reaching Agreement in the Presence of Faults</a> 或<a href="https://en.wikipedia.org/wiki/Byzantine_fault">Wikipedia: Byzantine Fault</a>，以了解更多的这些概念以及阈值的来源.</p>
<p>并非所有共识协议都定义了一个单一的、规范性的链。 有些协议在具有共同父节点的两个区块的状态变化不冲突时，可以验证<a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graphs</a> (DAG) 。</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/zh-CN/knowledgebase/advanced/codec"><span class="arrow-prev">← </span><span>SCALE 编解码器</span></a><a class="docs-next button" href="/docs/zh-CN/knowledgebase/advanced/block-import"><span>区块导入过程</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#状态机和冲突">状态机和冲突</a></li><li><a href="#冲突排除">冲突排除</a></li><li><a href="#分叉选择规则">分叉选择规则</a><ul class="toc-headings"><li><a href="#最长链规则">最长链规则</a></li><li><a href="#ghost-规则">GHOST 规则</a></li></ul></li><li><a href="#区块生成">区块生成</a><ul class="toc-headings"><li><a href="#工作量证明">工作量证明</a></li><li><a href="#时隙">时隙</a></li></ul></li><li><a href="#最终确定性">最终确定性</a></li><li><a href="#substrate中的共识">Substrate中的共识</a><ul class="toc-headings"><li><a href="#aura">Aura</a></li><li><a href="#babe">BABE</a></li><li><a href="#工作量证明-1">工作量证明</a></li><li><a href="#grandpa">GRANDPA</a></li><li><a href="#与runtime协作">与Runtime协作</a></li></ul></li><li><a href="#进一步学习">进一步学习</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/Substrate-logo.svg" alt="Substrate Developer Hub" width="66" height="58"/></a><div><h5>开发者中心</h5><a href="/zh-CN/tutorials">教程</a><a href="/docs/zh-CN/">知识库</a><a href="https://substrate.dev/recipes/">进阶菜谱</a><a href="https://substrate.dev/rustdocs">API 文档</a></div><div><h5>社区</h5><a href="/zh-CN/community">社区主页</a><a href="/zh-CN/newsletter">通讯</a><a href="https://app.element.io/#/room/!HzySYSaIhtyWrwiwEV:matrix.org">Substrate 技术聊天室</a><a href="/zh-CN/seminar">Substrate 研讨会</a><a href="http://stackoverflow.com/questions/tagged/substrate" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://twitter.com/ParityTech" target="_blank" rel="noreferrer noopener">推特</a><a href="https://www.meetup.com/parity/" target="_blank" rel="noreferrer noopener">事件 (Events)</a></div><div><h5>更多</h5><a href="https://www.substrate.io/builders-program/">Substrate Builders 计划</a><a href="https://www.parity.io/blog/">Blog</a><a href="https://github.com/paritytech/substrate">Substrate GitHub</a><a href="https://github.com/substrate-developer-hub/">开发者中心 GitHub</a><a href="https://www.parity.io/privacy/">隐私政策</a><a href="/terms">使用条款</a><a href="#" id="cookie-settings">Cookie 设置<script>
                var cookieSettings = document.getElementById('cookie-settings');
                cookieSettings.onclick = function() {
                  return klaro.show();
                };
              </script></a></div></section><section class="copyright">Copyright © 2021 Parity Technologies</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '5cd09916f4ba4c283b2d45ee7386fc34',
                indexName: 'substrate',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:zh-CN"]}
              });
            </script></body></html>